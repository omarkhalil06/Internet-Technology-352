/**
 * 
 * @author Omar Khalil ok77
 *
 */

import java.net.*;
import java.io.*;
import java.util.*;
import givenTools.TorrentInfo;
import java.security.*;
import java.net.InetAddress;

public class Peer implements Runnable {

	private static byte[] bit_protocol = new byte[] {'B','i','t','T','o','r','r','e','n','t',' ','p','r','o','t','o','c','o','l'};
	private byte[] peer_id;
	private byte[] info_hash;
	private String ip;
	private int port;
	private Socket socket;
	private DataInputStream din;
	private DataOutputStream dout;
	private TorrentInfo torrent_info;
	private FileOutputStream fout;
	
	private Tracker tracker = RUBTClient.tracker;
	private static byte[] downloaded_file;
	
	public boolean download_complete;
	
	public Peer(byte[] peer_id, String ip, int port, byte[] info_hash, TorrentInfo torrent_info) {
		this.peer_id = peer_id;
		this.ip = ip;
		this.port = port;
		this.info_hash = info_hash;
		this.torrent_info = torrent_info;
	}

	public void run() {

		try {
			// connects to peer
			socket = new Socket(ip, port);
			dout = new DataOutputStream(socket.getOutputStream());
			din = new DataInputStream(socket.getInputStream());
			System.out.println("Connecting to peer from " + ip);
			
			System.out.println("Sending handshake ...");
			if (handshake()) {
				System.out.println("Handshake successful!");
				
				Message interested = new Message(1, (byte) 2);
				System.out.println("Interested message has been sent to peer. Waiting for unchoke message ...");
				
				// wait for unchoke message
				boolean unchoked = false;
				while (!unchoked) {
					sendMessage(interested.message);
					
					int length = din.readInt();
					byte id = din.readByte();
					Message response = getMessage(id, length);
					if (response.getID() == Message.UNCHOKE) {
						unchoked = true;
					}
				}
				System.out.println("Unchoked! Begin downloading ...");
				tracker.sendRequest("started");

				// download file
				downloaded_file = new byte[torrent_info.file_length];
				double start = System.nanoTime();
				download();
				double finish = System.nanoTime();
				double elapsed_time = (finish - start) / 1000000000;
				System.out.println("Download time: " + elapsed_time + " seconds");
				
				// save file
				try {
					fout.write(downloaded_file);
				} catch (IOException e) {
					System.err.println("Error in saving file");
					e.printStackTrace();
				}
				
			} else {
				System.err.println("Handshake failed!");
				return;
			}
		} catch (IOException e) {
			System.err.println("Connection failed");
			//e.printStackTrace();
		}

		// close sockets and stream readers
		try {
			socket.close();
			din.close();
			dout.close();
			fout.close();
		} catch (IOException e) {
			System.err.println("Cannot close");
			//e.printStackTrace();
		}
	}

	/**
	 * Generates a handshake to send to the peer.
	 * 
	 * @return True if handshake between peers is equal. Otherwise, return false.
	 */
	public boolean handshake() {
		// begins with byte 19
		byte[] handshake_message = new byte[68];
		handshake_message[0] = (byte) 19;

		// "BitTorrent protocol" 
		System.arraycopy(bit_protocol, 0, handshake_message, 1, bit_protocol.length);
		int index = 1 + bit_protocol.length;
		
		// 8 reserved bytes that are set to 0
		byte[] reserved_bytes = new byte[8];
		System.arraycopy(reserved_bytes, 0, handshake_message, index, reserved_bytes.length);
		
		// 20-byte SHA-1 hash of the bencoded form of the torrent info value
		index += reserved_bytes.length;
		System.arraycopy(info_hash, 0, handshake_message, index, info_hash.length);

		// peed id generated by the client
		byte[] generated_ID = tracker.peer_id.getBytes();
		index += info_hash.length;
		System.arraycopy(generated_ID, 0, handshake_message, index, generated_ID.length);

		// send message and compare handshakes
		try {
			dout.write(handshake_message);
			dout.flush();
			
			byte[] received_handshake = new byte[68];
			din.read(received_handshake);

			byte[] check = Arrays.copyOfRange(received_handshake, 28,48);
			if (Arrays.equals(info_hash, check)) {
				return true;
			} else {
				System.err.println("Not equal");
			}
		} catch (IOException e) {
			System.err.println("Handshake failed.");
			//e.printStackTrace();
		}

		return false;
	}

	/**
	 * Sends a message to the peer.
	 * 
	 * @param message
	 */
	public void sendMessage(byte[] message) {
		try {
			dout.write(message);
			dout.flush();
		} catch(IOException e) {
			System.err.println("Unable to send message.");
			e.printStackTrace();
		}
	}
	
	/**
	 * Retrieves a message from the peer.
	 * 
	 * @param id 
	 * @param length 
	 * @return Message
	 */
	public Message getMessage(byte id, int length) {
		try {
			switch(id) {
			case(Message.CHOKE):
				return new Message(1, id);
			case(Message.UNCHOKE):
				return new Message(1, id);
			case(Message.INTERESTED):
				return new Message(1, id);
			case(Message.UNINTERESTED):
				return new Message(1, id);
			case(Message.HAVE):
				int peer_index = din.readInt();
				return new Have(peer_index);
			case(Message.BITFIELD):
				byte[] bitfield = new byte[length - 1];
				din.readFully(bitfield);
				return new Bitfield(bitfield);
			case(Message.PIECE):
				int index = din.readInt();
				int begin = din.readInt();
				byte[] block = new byte[length];
				return new Piece(index, begin, block);
			} 
		} catch (IOException e) {
			System.err.println("Getting message error");
		}
		
		return null;

	}
	
	/**
	 * Checks if the file to be saved has been started already. If so, reads all pieces from the save file to
	 * the downloaded file array by verifying its SHA-1 hash. Returns the index of the piece if verifying its
	 * SHA-1 hash value fails. 
	 * 
	 * @return int This returns index of piece
	 */
	public int checkFileAndGetIndex() {
		File file = new File(RUBTClient.save_file);
		FileInputStream fis;
		
		if (file.exists()) {
			try {
				fis = new FileInputStream(file);
				int count = 0; 	
				int pieces = torrent_info.piece_hashes.length;
				
				while (count != pieces) {
					byte[] piece;
					if (count == pieces - 1) {
						if (torrent_info.file_length % torrent_info.piece_length == 0) {
							piece = new byte[torrent_info.piece_length];
						} else {
							piece = new byte[torrent_info.file_length % torrent_info.piece_length];
						}
					} else {
						piece = new byte[torrent_info.piece_length];
					}
					
					fis.read(piece);
					if (verifySHA1(piece, count)) {
						System.arraycopy(piece, 0, downloaded_file, count * torrent_info.piece_length, piece.length);
						tracker.downloaded += torrent_info.piece_length;
						tracker.left -= torrent_info.piece_length;
					} else {
						fis.close();
						System.out.println("Continued at index: " + count);
						return count;
					}
					
					count++;
				}
				
				fis.close();
			} catch (IOException e) {
				System.err.println("File input stream error");
				e.printStackTrace();
			}
		}
		
		return 0;
	}

	/**
	 * Downloads all pieces and verifies its SHA-1 hash value. Client can enter <quit> 
	 * to stop download whenever and pieces will still be saved.
	 * 
	 */
	public void download() {		
		int count = checkFileAndGetIndex();
		int pieces = torrent_info.piece_hashes.length;
		if (count == pieces) {
			tracker.sendRequest("completed");
			System.out.println("File has been already downloaded");
			return;
		}
		
		download_complete = false;
		Thread thread = new Thread(new keepAlive());
		thread.start();
		
		try {
			fout = new FileOutputStream(new File(RUBTClient.save_file));
		} catch (IOException e) {
			System.err.println("File error");
			//e.printStackTrace();
		}		
		
		System.out.println("Total number of pieces: " + pieces);
		
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		System.out.println("Enter <quit> to stop download");
		
		while (count != pieces) {
			try {
				if (br.ready()) {
					if (br.readLine().equals("quit")) {
						download_complete = true;
						tracker.sendRequest("stopped");
						return;
					}
				}
			} catch (IOException e) {
				System.err.println("User input error");
			}
				
			byte[] piece;
			int blocks = torrent_info.piece_length / 16384;
			int begin = 0;
			
			if (count == pieces - 1) {
				if (torrent_info.file_length % torrent_info.piece_length == 0) {
					piece = new byte[torrent_info.piece_length];
				} else {
					piece = new byte[torrent_info.file_length % torrent_info.piece_length];
				}
			} else {
				piece = new byte[torrent_info.piece_length];
			}
			
			int i = 0;
			while (i < blocks) {
				
				int block_length = 16384;
				
				if (i == blocks - 1 && piece.length % 16384 != 0) {
					if (piece.length % 16384 != 0) {
						block_length = piece.length % 16384;
					}
				}
				
				try {
					Message request = new Request(count, begin, block_length);
					dout.write(request.message);
					dout.flush();
					
					int piece_length = din.readInt() - 9;
					byte id = din.readByte();
					int piece_index = din.readInt();
					int piece_begin = din.readInt();
					
					//System.out.println("Piece length: " + piece_length);
					//System.out.println("ID: " + id);
					//System.out.println("Index: " + piece_index);
					//System.out.println("Begin: " + piece_begin);
					
					if (id == Message.PIECE) {
						byte[] block = new byte[piece_length];
						din.readFully(block);
						System.arraycopy(block, 0, piece, piece_begin, piece_length);
						begin += 16384;
					}
				} catch (IOException e) {
					System.err.println("Error in request message");
					//e.printStackTrace();
				}
				
				i++;
			}
			
			if (verifySHA1(piece, count)) {
				tracker.downloaded += piece.length;
				tracker.left -= piece.length;
				System.arraycopy(piece, 0, downloaded_file, count * torrent_info.piece_length, piece.length);
				System.out.println("Piece #" + count + " verified!");
			}
			
			count++;
				
		}
		
		download_complete = true;
		tracker.sendRequest("completed");

	}

	/**
	 * Obtains a specific piece and verifies its SHA-1 hash value.
	 * 
	 * @param piece
	 * @param count
	 * @return True if SHA-1 is verified. False otherwise.
	 */
	public boolean verifySHA1(byte[] piece, int count) {
		MessageDigest md = null;
		byte[] b = null;
		try {
			md = MessageDigest.getInstance("SHA-1");
			b = md.digest(piece);
		} catch (NoSuchAlgorithmException e) {
			System.err.println("Verifying SHA-1 error");
			//e.printStackTrace();
		}

		byte[] check = torrent_info.piece_hashes[count].array();
		if (Arrays.equals(b, check)) {
			return true;
		}

		return false;
		
	}

	/**
	 * Sends out a ping to the peers ip address and calculates its average 
	 * RTT over 10 times.
	 * 
	 * @return double
	 */
	public double calculateAverageRTT() {
		try {
			InetAddress inet = InetAddress.getByName(ip);

			double start = System.nanoTime();			
			for (int i = 0; i < 10; i++) {
				inet.isReachable(120000);
			}
			double finish = System.nanoTime();		

			double average = (finish - start) / 10; 
			System.out.println("Average RTT for " + ip + ": " + average + " ms");
			return average;
			
		} catch (Exception e) {
			System.err.println("Unreachable");
			//e.printStackTrace();
		}
		
		return -1;
	}
	
	public byte[] getPeerID() {
		return peer_id;
	}

	public int getPort() {
		return port;
	}

	public String getIP() {
		return ip;
	}
	
	/**
	 * Class used to send keep alive messages to peer every 2 minutes to prevent peers from closing
	 * connections.
	 * 
	 */
	public class keepAlive implements Runnable {
		
		boolean running = true;

		public void run() {
			int timer = 120;
			while (running) {
				try {
					Thread.sleep(1000L);
					timer--;
				} catch (InterruptedException e) {
					// do nothing
				}
				
				if (timer == 0) {
					Message alive = new Message(0, Message.KEEP_ALIVE);
					try {
						dout.writeInt(0);
					} catch (IOException e) {
						System.err.println("Keep alive message error");
						//e.printStackTrace();
					}
					timer = 0;
				}
				
				if (download_complete) {
					running = false;
				}
			}
			
		}
		
	}

}